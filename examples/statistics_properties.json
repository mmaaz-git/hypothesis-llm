{
  "module_name": "statistics",
  "single_function_properties": {
    "mean": [
      {
        "property": "Error condition: mean([]) raises StatisticsError",
        "reasoning": "The docstring explicitly states 'If data is empty, StatisticsError will be raised' and the source code checks 'if n < 1: raise StatisticsError'",
        "confidence": "certain"
      },
      {
        "property": "Bounded output: min(data) \u2264 mean(data) \u2264 max(data)",
        "reasoning": "The arithmetic mean of a dataset must always lie between the minimum and maximum values by mathematical definition",
        "confidence": "certain"
      },
      {
        "property": "Single element invariant: mean([x]) == x",
        "reasoning": "The mean of a single element should equal that element itself, as sum/count = x/1 = x",
        "confidence": "certain"
      },
      {
        "property": "Linear scaling: mean([k*x for x in data]) == k * mean(data)",
        "reasoning": "Multiplying all elements by a constant k should multiply the mean by k, following the distributive property of arithmetic",
        "confidence": "high"
      },
      {
        "property": "Translation invariant: mean([x+c for x in data]) == mean(data) + c",
        "reasoning": "Adding a constant c to all elements should add c to the mean, as (sum + n*c)/n = sum/n + c",
        "confidence": "high"
      },
      {
        "property": "Concatenation property: mean(a + b) relates to mean(a), mean(b), len(a), len(b)",
        "reasoning": "The mean of concatenated lists should equal (len(a)*mean(a) + len(b)*mean(b))/(len(a)+len(b)) by weighted average formula",
        "confidence": "high"
      },
      {
        "property": "Order independence: mean(data) == mean(shuffled(data))",
        "reasoning": "The arithmetic mean should be independent of the order of elements since it's just sum/count",
        "confidence": "certain"
      },
      {
        "property": "Type preservation: type(mean(data)) relates to type of data elements",
        "reasoning": "The examples show Fraction inputs yield Fraction output, Decimal inputs yield Decimal output, suggesting type preservation behavior",
        "confidence": "medium"
      },
      {
        "property": "Duplicate invariant: mean([x]*n) == x",
        "reasoning": "The mean of n identical values should equal that value, as (x*n)/n = x",
        "confidence": "certain"
      }
    ],
    "median": [
      {
        "property": "Bounded output: min(data) \u2264 median(data) \u2264 max(data)",
        "reasoning": "The median is always between the minimum and maximum values of the dataset. This follows directly from the definition - for odd length, it's a middle element; for even length, it's the average of two middle elements.",
        "confidence": "certain"
      },
      {
        "property": "Order invariance: median(data) == median(sorted(data))",
        "reasoning": "The function explicitly sorts the input data, so the median should be the same regardless of the input order. This is a fundamental property of the median statistic.",
        "confidence": "certain"
      },
      {
        "property": "Empty data error: median([]) raises StatisticsError",
        "reasoning": "The source code explicitly checks for empty data and raises StatisticsError with the message 'no median for empty data'.",
        "confidence": "certain"
      },
      {
        "property": "Single element identity: median([x]) == x",
        "reasoning": "For a single element list, n=1 (odd), so the function returns data[0] which is the single element x.",
        "confidence": "certain"
      },
      {
        "property": "Odd length returns middle element: for odd len(data), median(data) in data",
        "reasoning": "When n is odd, the code returns data[n // 2], which is an actual element from the sorted data list.",
        "confidence": "certain"
      },
      {
        "property": "Even length interpolation: for even len(data), median(data) == (data[n//2-1] + data[n//2]) / 2",
        "reasoning": "The source code explicitly implements this formula when n is even, calculating the average of the two middle elements.",
        "confidence": "certain"
      },
      {
        "property": "Duplicate handling: median([x, x, ..., x]) == x",
        "reasoning": "For any list of identical values, whether odd or even length, the median will be x (either the middle element or average of identical middle elements).",
        "confidence": "certain"
      },
      {
        "property": "Two element average: median([a, b]) == (a + b) / 2",
        "reasoning": "For exactly two elements, n=2 (even), so i=1, and the function returns (data[0] + data[1]) / 2, which is the average of the two sorted elements.",
        "confidence": "certain"
      },
      {
        "property": "Monotonicity preservation: if all elements in data1 \u2264 corresponding elements in data2 (same length), then median(data1) \u2264 median(data2)",
        "reasoning": "Since median depends on the middle elements of sorted data, if one dataset has all elements \u2264 the corresponding elements of another dataset of the same length, the median will also follow this ordering.",
        "confidence": "high"
      },
      {
        "property": "Scale invariance: median([k*x for x in data]) == k * median(data) for k > 0",
        "reasoning": "Multiplying all elements by a positive constant scales the median by the same constant, as both the middle element (odd case) and average of middle elements (even case) scale linearly.",
        "confidence": "high"
      }
    ],
    "mode": [
      {
        "property": "Empty data raises StatisticsError",
        "reasoning": "The docstring explicitly states 'If *data* is empty, ``mode``, raises StatisticsError' and the source code shows this behavior with 'raise StatisticsError('no mode for empty data')'",
        "confidence": "certain"
      },
      {
        "property": "Return value is always an element from the input data",
        "reasoning": "The function uses Counter to count elements and returns pairs[0][0], which is guaranteed to be an element from the original data. This is a fundamental property of the mode operation.",
        "confidence": "certain"
      },
      {
        "property": "Single element data returns that element",
        "reasoning": "If data contains only one element, that element has the highest frequency (1) and will be returned by Counter.most_common(1). This follows from the definition of mode.",
        "confidence": "certain"
      },
      {
        "property": "First occurrence wins for ties",
        "reasoning": "The docstring explicitly states 'If there are multiple modes with same frequency, return the first one encountered' with an example showing 'red' being returned over 'blue' when both have frequency 2.",
        "confidence": "certain"
      },
      {
        "property": "Works with any hashable data types",
        "reasoning": "The docstring shows examples with both numeric data [1, 1, 2, 3, 3, 3, 3, 4] and string data ['red', 'blue', 'blue', 'red', 'green', 'red', 'red']. Counter can work with any hashable type.",
        "confidence": "high"
      },
      {
        "property": "Returned element has maximum frequency in the data",
        "reasoning": "By definition of mode and the use of Counter.most_common(1), the returned element must have the highest count among all elements in the data.",
        "confidence": "certain"
      },
      {
        "property": "Function is deterministic for the same input",
        "reasoning": "Given the same input data in the same order, the function will always return the same result due to the deterministic behavior of Counter and the tie-breaking rule (first occurrence).",
        "confidence": "high"
      },
      {
        "property": "Order preservation for tie-breaking",
        "reasoning": "When multiple elements have the same highest frequency, the function returns the one that appeared first in the iteration order of the input data, as demonstrated in the docstring example.",
        "confidence": "high"
      }
    ],
    "stdev": [
      {
        "property": "Non-negative output: stdev(data) >= 0",
        "reasoning": "Standard deviation is defined as the square root of variance, which is always non-negative by mathematical definition. The function returns the result of _float_sqrt_of_frac or _decimal_sqrt_of_frac, both of which compute square roots.",
        "confidence": "certain"
      },
      {
        "property": "Error condition: stdev(data) raises StatisticsError when len(data) < 2",
        "reasoning": "The source code explicitly checks 'if n < 2' and raises StatisticsError with message 'stdev requires at least two data points'. This is a definitive error condition based on the implementation.",
        "confidence": "certain"
      },
      {
        "property": "Scale invariance: stdev([k*x for x in data]) == abs(k) * stdev(data) for k != 0",
        "reasoning": "Standard deviation scales linearly with the absolute value of scaling factor. This is a fundamental mathematical property of standard deviation that should hold for any correct implementation.",
        "confidence": "high"
      },
      {
        "property": "Translation invariance: stdev([x + c for x in data]) == stdev(data)",
        "reasoning": "Adding a constant to all data points does not change the standard deviation, as it measures spread around the mean, not absolute position. This is a core mathematical property of standard deviation.",
        "confidence": "high"
      },
      {
        "property": "Zero deviation for constant data: stdev([c, c, ..., c]) == 0",
        "reasoning": "When all data points are identical, there is no variation, so standard deviation should be exactly zero. This follows from the mathematical definition and the fact that variance would be zero.",
        "confidence": "high"
      },
      {
        "property": "Consistency with xbar parameter: stdev(data, xbar) == stdev(data) when xbar equals the actual mean",
        "reasoning": "The xbar parameter allows providing a pre-computed mean. When it equals the actual mean of the data, the result should be identical to not providing it. This is evident from the function signature and docstring reference to variance.",
        "confidence": "high"
      },
      {
        "property": "Single duplication invariance: stdev([x, x]) == 0",
        "reasoning": "For exactly two identical values, the standard deviation should be zero as there is no variation. This is the minimal case that doesn't trigger the n < 2 error condition.",
        "confidence": "high"
      },
      {
        "property": "Relationship to variance: stdev(data) == sqrt(variance(data))",
        "reasoning": "The docstring explicitly states this function returns 'the square root of the sample variance' and references the variance function for details. This is the defining relationship.",
        "confidence": "medium"
      }
    ],
    "variance": [
      {
        "property": "Non-negative result: variance(data) >= 0",
        "reasoning": "Sample variance is always non-negative by mathematical definition - it's the average of squared deviations from the mean. This is a fundamental property of variance calculations.",
        "confidence": "certain"
      },
      {
        "property": "Zero variance for constant data: variance([c, c, ...]) == 0",
        "reasoning": "When all data points are identical, there is no variation, so variance must be zero. This follows directly from the variance formula where all deviations from the mean are zero.",
        "confidence": "certain"
      },
      {
        "property": "Error condition: variance(data) raises StatisticsError when len(data) < 2",
        "reasoning": "The docstring explicitly states 'data should be an iterable of Real-valued numbers, with at least two values' and the source code shows 'if n < 2: raise StatisticsError'. Sample variance is undefined for fewer than 2 points.",
        "confidence": "certain"
      },
      {
        "property": "Mean consistency: variance(data, mean(data)) == variance(data)",
        "reasoning": "The docstring shows this exact example and states that passing the correct mean as xbar should give the same result as auto-calculating it. This is a key behavioral guarantee.",
        "confidence": "certain"
      },
      {
        "property": "Scale invariance of normalized variance: variance([k*x for x in data]) == k\u00b2*variance(data) for k != 0",
        "reasoning": "Scaling all data points by a constant k scales the variance by k\u00b2. This is a fundamental algebraic property of variance under linear transformations.",
        "confidence": "high"
      },
      {
        "property": "Translation invariance: variance([x + c for x in data]) == variance(data)",
        "reasoning": "Adding a constant to all data points doesn't change the spread/variance, only shifts the mean. The deviations from the mean remain the same, so variance is unchanged.",
        "confidence": "high"
      },
      {
        "property": "Type preservation: type(variance(data)) matches the numeric type of data elements",
        "reasoning": "The docstring explicitly shows examples with Decimal and Fraction types, and states these are supported. The function should preserve the input numeric type in the output.",
        "confidence": "high"
      },
      {
        "property": "Minimum variance bound: variance(data) >= 0, with equality only when all elements are equal",
        "reasoning": "This extends the non-negative property - variance is zero if and only if there's no variation in the data. This is the precise condition for when the minimum bound is achieved.",
        "confidence": "high"
      },
      {
        "property": "Order independence: variance(data) == variance(permutation_of_data)",
        "reasoning": "Variance depends only on the values and their frequencies, not their order. Any permutation of the same data should yield the same variance.",
        "confidence": "high"
      },
      {
        "property": "Duplicate value handling: variance(data + data) has different value but same relative relationships",
        "reasoning": "Adding duplicate values changes the sample size (n) in the denominator (n-1), affecting the final variance value. The behavior should be mathematically consistent with the sample variance formula.",
        "confidence": "medium"
      }
    ]
  },
  "multi_function_properties": [
    {
      "property": "stdev(data) == sqrt(variance(data))",
      "reasoning": "The stdev function is documented as 'Return the square root of the sample variance' and references the variance function for details. This establishes a direct mathematical relationship between the two functions.",
      "functions_involved": [
        "stdev",
        "variance"
      ],
      "confidence": "certain"
    },
    {
      "property": "variance(data, mean(data)) == variance(data, None)",
      "reasoning": "The variance function documentation states that xbar should be the mean of the data, and when missing or None, the mean is automatically calculated. This means passing the computed mean should yield identical results to letting variance calculate it internally.",
      "functions_involved": [
        "variance",
        "mean"
      ],
      "confidence": "certain"
    },
    {
      "property": "stdev(data, mean(data)) == stdev(data, None)",
      "reasoning": "Similar to variance, the stdev function accepts an optional xbar parameter and references variance for details. The same mean-passing equivalence should apply.",
      "functions_involved": [
        "stdev",
        "mean"
      ],
      "confidence": "high"
    },
    {
      "property": "For single-element data [x]: mean([x]) == median([x]) == mode([x]) == x",
      "reasoning": "For a dataset with only one element, all three measures of central tendency should return that single value. Mean sums and divides by 1, median returns the middle (only) value, and mode returns the most frequent (only) value.",
      "functions_involved": [
        "mean",
        "median",
        "mode"
      ],
      "confidence": "certain"
    },
    {
      "property": "For constant data [x, x, ..., x]: mean(data) == median(data) == mode(data) == x",
      "reasoning": "When all elements in a dataset are identical, all measures of central tendency must equal that constant value. Mean averages identical values to the same value, median finds the middle of identical values, and mode finds the most frequent value.",
      "functions_involved": [
        "mean",
        "median",
        "mode"
      ],
      "confidence": "certain"
    },
    {
      "property": "For two-element data [a, b]: variance([a, b]) == stdev([a, b])^2",
      "reasoning": "This verifies the fundamental relationship between variance and standard deviation (stdev = sqrt(variance)) for the minimal case where both functions are defined (requiring at least 2 data points).",
      "functions_involved": [
        "variance",
        "stdev"
      ],
      "confidence": "certain"
    }
  ]
}