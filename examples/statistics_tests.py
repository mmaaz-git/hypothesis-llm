"""Property-based tests for statistics module.
Generated by hypothesis-llm.
"""

import hypothesis
from hypothesis import given, strategies as st
from statistics import (
    mean,
    median,
    mode,
    stdev,
    variance
)


@given(st.just([]))
def test_mean_empty_list_raises_error(data):
    """Test that mean([]) raises StatisticsError"""
    import pytest
    with pytest.raises(StatisticsError):
        mean(data)


@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))
def test_mean_bounded_by_min_max(data):
    """Test that min(data) ≤ mean(data) ≤ max(data)"""
    result = mean(data)
    assert min(data) <= result <= max(data)


@given(st.floats(allow_nan=False, allow_infinity=False))
def test_mean_single_element_invariant(x):
    """Test that mean([x]) == x for any single element"""
    import math
    result = mean([x])
    assert math.isclose(result, x, rel_tol=1e-9)


@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1), 
       st.floats(allow_nan=False, allow_infinity=False, min_value=-1e6, max_value=1e6))
def test_mean_linear_scaling(data, k):
    """Test that mean([k*x for x in data]) == k * mean(data)"""
    import math
    scaled_data = [k * x for x in data]
    original_mean = mean(data)
    scaled_mean = mean(scaled_data)
    expected = k * original_mean
    assert math.isclose(scaled_mean, expected, rel_tol=1e-9)


@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1),
       st.floats(allow_nan=False, allow_infinity=False, min_value=-1e6, max_value=1e6))
def test_mean_translation_invariant(data, c):
    """Test that mean([x+c for x in data]) == mean(data) + c"""
    import math
    translated_data = [x + c for x in data]
    original_mean = mean(data)
    translated_mean = mean(translated_data)
    expected = original_mean + c
    assert math.isclose(translated_mean, expected, rel_tol=1e-9)


@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1),
       st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))
def test_mean_concatenation_property(a, b):
    """Test that mean(a + b) == (len(a)*mean(a) + len(b)*mean(b)) / (len(a) + len(b))"""
    import math
    concatenated = a + b
    concatenated_mean = mean(concatenated)
    
    mean_a = mean(a)
    mean_b = mean(b)
    expected = (len(a) * mean_a + len(b) * mean_b) / (len(a) + len(b))
    
    assert math.isclose(concatenated_mean, expected, rel_tol=1e-9)


@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1))
def test_mean_order_independence(data):
    """Test that mean(data) == mean(shuffled(data))"""
    import math
    import random
    
    original_mean = mean(data)
    shuffled_data = data.copy()
    random.shuffle(shuffled_data)
    shuffled_mean = mean(shuffled_data)
    
    assert math.isclose(original_mean, shuffled_mean, rel_tol=1e-9)


@given(st.one_of(
    st.lists(st.integers(), min_size=1),
    st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=1)
))
def test_mean_type_preservation(data):
    """Test that mean preserves reasonable type relationships with input data"""
    result = mean(data)
    
    if all(isinstance(x, int) for x in data):
        # For integer inputs, result should be int or float
        assert isinstance(result, (int, float))
    elif all(isinstance(x, float) for x in data):
        # For float inputs, result should be float
        assert isinstance(result, float)


@given(st.floats(allow_nan=False, allow_infinity=False),
       st.integers(min_value=1, max_value=100))
def test_mean_duplicate_invariant(x, n):
    """Test that mean([x]*n) == x"""
    import math
    data = [x] * n
    result = mean(data)
    assert math.isclose(result, x, rel_tol=1e-9)


@given(st.lists(st.fractions(), min_size=1))
def test_mean_fraction_type_preservation(data):
    """Test that mean preserves Fraction type"""
    from fractions import Fraction
    result = mean(data)
    assert isinstance(result, Fraction)


@given(st.lists(st.decimals(allow_nan=False, allow_infinity=False), min_size=1))
def test_mean_decimal_type_preservation(data):
    """Test that mean preserves Decimal type"""
    from decimal import Decimal
    result = mean(data)
    assert isinstance(result, Decimal)

@given(st.lists(st.integers(), min_size=1))
def test_bounded_output(data):
    """Test that median is bounded by min and max of data."""
    result = median(data)
    assert min(data) <= result <= max(data)

@given(st.lists(st.integers(), min_size=1))
def test_order_invariance(data):
    """Test that median is invariant to the order of input data."""
    import random
    shuffled_data = data.copy()
    random.shuffle(shuffled_data)
    assert median(data) == median(sorted(data))
    assert median(data) == median(shuffled_data)

def test_empty_data_error():
    """Test that median raises StatisticsError for empty data."""
    import pytest
    with pytest.raises(Exception):  # StatisticsError inherits from ValueError
        median([])

@given(st.integers())
def test_single_element_identity(x):
    """Test that median of single element returns that element."""
    assert median([x]) == x

@given(st.lists(st.integers(), min_size=1).filter(lambda x: len(x) % 2 == 1))
def test_odd_length_returns_middle_element(data):
    """Test that for odd length data, median returns the middle element."""
    result = median(data)
    assert result in data

@given(st.lists(st.integers(), min_size=2).filter(lambda x: len(x) % 2 == 0))
def test_even_length_interpolation(data):
    """Test that for even length data, median is average of two middle elements."""
    import math
    sorted_data = sorted(data)
    n = len(sorted_data)
    expected = (sorted_data[n//2 - 1] + sorted_data[n//2]) / 2
    result = median(data)
    assert math.isclose(result, expected)

@given(st.integers(), st.integers(min_value=1, max_value=20))
def test_duplicate_handling(x, count):
    """Test that median of all identical elements returns that element."""
    data = [x] * count
    assert median(data) == x

@given(st.integers(), st.integers())
def test_two_element_average(a, b):
    """Test that median of two elements is their average."""
    import math
    result = median([a, b])
    expected = (a + b) / 2
    assert math.isclose(result, expected)

@given(st.lists(st.integers(), min_size=1, max_size=10))
def test_monotonicity_preservation(data1):
    """Test that if all elements in data1 ≤ corresponding elements in data2, then median(data1) ≤ median(data2)."""
    # Create data2 where each element is >= corresponding element in data1
    data2 = [x + abs(x) + 1 for x in data1]  # Ensures data2[i] >= data1[i]
    assert median(data1) <= median(data2)

@given(st.lists(st.integers(min_value=-100, max_value=100), min_size=1), 
       st.integers(min_value=1, max_value=10))
def test_scale_invariance(data, k):
    """Test that median([k*x for x in data]) == k * median(data) for k > 0."""
    import math
    scaled_data = [k * x for x in data]
    result = median(scaled_data)
    expected = k * median(data)
    assert math.isclose(result, expected)

@given(st.just([]))
def test_empty_data_raises_statistics_error(data):
    """Test that empty data raises StatisticsError."""
    import pytest
    from statistics import StatisticsError
    
    with pytest.raises(StatisticsError, match="no mode for empty data"):
        mode(data)


@given(st.lists(st.integers(), min_size=1))
def test_return_value_is_element_from_input_data_integers(data):
    """Test that the returned mode is always an element from the input data (integers)."""
    result = mode(data)
    assert result in data


@given(st.lists(st.text(), min_size=1))
def test_return_value_is_element_from_input_data_strings(data):
    """Test that the returned mode is always an element from the input data (strings)."""
    result = mode(data)
    assert result in data


@given(st.integers())
def test_single_element_data_returns_that_element(element):
    """Test that single element data returns that element."""
    data = [element]
    result = mode(data)
    assert result == element


def test_first_occurrence_wins_for_ties():
    """Test that when multiple elements have the same maximum frequency, the first one encountered wins."""
    # Create data where 'red' appears first and has same frequency as 'blue'
    data = ['red', 'red', 'blue', 'blue', 'green']
    result = mode(data)
    assert result == 'red'
    
    # Test with different order
    data = ['blue', 'blue', 'red', 'red', 'green']
    result = mode(data)
    assert result == 'blue'


@given(st.lists(st.integers(), min_size=1))
def test_works_with_integers(data):
    """Test that mode works with integer data."""
    result = mode(data)
    assert isinstance(result, int)
    assert result in data


@given(st.lists(st.text(), min_size=1))
def test_works_with_strings(data):
    """Test that mode works with string data."""
    result = mode(data)
    assert isinstance(result, str)
    assert result in data


@given(st.lists(st.tuples(st.integers(), st.text()), min_size=1))
def test_works_with_tuples(data):
    """Test that mode works with tuple data (hashable)."""
    result = mode(data)
    assert isinstance(result, tuple)
    assert result in data


@given(st.lists(st.integers(), min_size=1))
def test_returned_element_has_maximum_frequency(data):
    """Test that the returned element has the maximum frequency in the data."""
    from collections import Counter
    
    result = mode(data)
    counter = Counter(data)
    max_frequency = max(counter.values())
    
    assert counter[result] == max_frequency


@given(st.lists(st.integers(), min_size=1))
def test_function_is_deterministic(data):
    """Test that the function returns the same result for the same input."""
    result1 = mode(data)
    result2 = mode(data)
    assert result1 == result2


def test_order_preservation_for_tie_breaking():
    """Test that order is preserved for tie-breaking across multiple scenarios."""
    # Test case 1: First element wins
    data1 = ['a', 'a', 'b', 'b', 'c']
    assert mode(data1) == 'a'
    
    # Test case 2: Middle element appears first among ties
    data2 = ['c', 'a', 'a', 'b', 'b']
    assert mode(data2) == 'a'
    
    # Test case 3: Last element appears first among ties  
    data3 = ['c', 'b', 'b', 'a', 'a']
    assert mode(data3) == 'b'


@given(st.lists(st.integers(), min_size=1))
def test_mode_with_all_elements_same_frequency(data):
    """Test mode when all elements appear exactly once (tie scenario)."""
    # Create data where each element appears exactly once
    unique_data = list(set(data))  # Remove duplicates
    if len(unique_data) > 1:
        result = mode(unique_data)
        # Should return the first element in the list
        assert result == unique_data[0]

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=20))
def test_stdev_non_negative_output(data):
    """Test that stdev always returns a non-negative value."""
    result = stdev(data)
    assert result >= 0

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0, max_size=1))
def test_stdev_error_condition_insufficient_data(data):
    """Test that stdev raises StatisticsError when given fewer than 2 data points."""
    import pytest
    with pytest.raises(StatisticsError):
        stdev(data)

@given(
    st.lists(st.floats(allow_nan=False, allow_infinity=False, min_value=-1e6, max_value=1e6), min_size=2, max_size=10),
    st.floats(allow_nan=False, allow_infinity=False, min_value=-100, max_value=100).filter(lambda x: x != 0)
)
def test_stdev_scale_invariance(data, k):
    """Test that stdev([k*x for x in data]) == abs(k) * stdev(data) for k != 0."""
    import math
    original_stdev = stdev(data)
    scaled_data = [k * x for x in data]
    scaled_stdev = stdev(scaled_data)
    expected = abs(k) * original_stdev
    assert math.isclose(scaled_stdev, expected, rel_tol=1e-10)

@given(
    st.lists(st.floats(allow_nan=False, allow_infinity=False, min_value=-1e6, max_value=1e6), min_size=2, max_size=10),
    st.floats(allow_nan=False, allow_infinity=False, min_value=-1000, max_value=1000)
)
def test_stdev_translation_invariance(data, c):
    """Test that stdev([x + c for x in data]) == stdev(data)."""
    import math
    original_stdev = stdev(data)
    translated_data = [x + c for x in data]
    translated_stdev = stdev(translated_data)
    assert math.isclose(translated_stdev, original_stdev, rel_tol=1e-10)

@given(
    st.floats(allow_nan=False, allow_infinity=False, min_value=-1000, max_value=1000),
    st.integers(min_value=2, max_value=10)
)
def test_stdev_zero_deviation_constant_data(c, n):
    """Test that stdev of constant data equals zero."""
    import math
    data = [c] * n
    result = stdev(data)
    assert math.isclose(result, 0, abs_tol=1e-15)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False, min_value=-1000, max_value=1000), min_size=2, max_size=10))
def test_stdev_consistency_with_xbar_parameter(data):
    """Test that stdev(data, xbar) == stdev(data) when xbar equals the actual mean."""
    import math
    mean_value = sum(data) / len(data)
    stdev_without_xbar = stdev(data)
    stdev_with_xbar = stdev(data, xbar=mean_value)
    assert math.isclose(stdev_without_xbar, stdev_with_xbar, rel_tol=1e-10)

@given(st.floats(allow_nan=False, allow_infinity=False, min_value=-1000, max_value=1000))
def test_stdev_single_duplication_invariance(x):
    """Test that stdev([x, x]) == 0."""
    import math
    data = [x, x]
    result = stdev(data)
    assert math.isclose(result, 0, abs_tol=1e-15)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False, min_value=-100, max_value=100), min_size=2, max_size=10))
def test_stdev_relationship_to_variance(data):
    """Test that stdev(data) == sqrt(variance(data))."""
    import math
    stdev_result = stdev(data)
    variance_result = variance(data)
    expected = math.sqrt(variance_result)
    assert math.isclose(stdev_result, expected, rel_tol=1e-10)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=50))
def test_variance_non_negative(data):
    """Test that variance is always non-negative."""
    result = variance(data)
    assert result >= 0

@given(st.floats(allow_nan=False, allow_infinity=False), st.integers(min_value=2, max_value=20))
def test_variance_zero_for_constant_data(constant_value, size):
    """Test that variance is zero when all data points are identical."""
    import math
    data = [constant_value] * size
    result = variance(data)
    assert math.isclose(result, 0, abs_tol=1e-10)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=0, max_size=1))
def test_variance_error_insufficient_data(data):
    """Test that variance raises StatisticsError when given fewer than 2 data points."""
    import pytest
    with pytest.raises(StatisticsError):
        variance(data)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=50))
def test_variance_mean_consistency(data):
    """Test that variance with explicit mean equals variance with computed mean."""
    import math
    from statistics import mean
    computed_variance = variance(data)
    explicit_mean_variance = variance(data, mean(data))
    assert math.isclose(computed_variance, explicit_mean_variance, rel_tol=1e-10)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False, min_value=-1e6, max_value=1e6), min_size=2, max_size=20),
       st.floats(allow_nan=False, allow_infinity=False, min_value=-10, max_value=10).filter(lambda x: abs(x) > 1e-6))
def test_variance_scale_invariance(data, scale_factor):
    """Test that variance scales by the square of the scaling factor."""
    import math
    original_variance = variance(data)
    scaled_data = [scale_factor * x for x in data]
    scaled_variance = variance(scaled_data)
    expected_variance = (scale_factor ** 2) * original_variance
    assert math.isclose(scaled_variance, expected_variance, rel_tol=1e-8)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=50),
       st.floats(allow_nan=False, allow_infinity=False))
def test_variance_translation_invariance(data, translation):
    """Test that variance is unchanged by adding a constant to all data points."""
    import math
    original_variance = variance(data)
    translated_data = [x + translation for x in data]
    translated_variance = variance(translated_data)
    assert math.isclose(original_variance, translated_variance, rel_tol=1e-10)

@given(st.lists(st.integers(min_value=-100, max_value=100), min_size=2, max_size=20))
def test_variance_type_preservation_integers(data):
    """Test that variance preserves integer type when appropriate."""
    result = variance(data)
    # For integers, result should be a fraction or float, but we test it doesn't crash
    assert isinstance(result, (int, float))

@given(st.lists(st.fractions(min_value=-10, max_value=10), min_size=2, max_size=10))
def test_variance_type_preservation_fractions(data):
    """Test that variance works with Fraction types."""
    from fractions import Fraction
    result = variance(data)
    assert isinstance(result, Fraction)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=20))
def test_variance_order_independence(data):
    """Test that variance is independent of data order."""
    import math
    import random
    original_variance = variance(data)
    shuffled_data = data.copy()
    random.shuffle(shuffled_data)
    shuffled_variance = variance(shuffled_data)
    assert math.isclose(original_variance, shuffled_variance, rel_tol=1e-10)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=25))
def test_variance_duplicate_value_handling(data):
    """Test that variance handles duplicated datasets appropriately."""
    original_variance = variance(data)
    duplicated_data = data + data
    duplicated_variance = variance(duplicated_data)
    # Both should be non-negative
    assert original_variance >= 0
    assert duplicated_variance >= 0
    # The relationship depends on the specific data, but both should be valid

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=20))
def test_variance_minimum_bound_equality_condition(data):
    """Test that variance equals zero if and only if all elements are equal."""
    import math
    result = variance(data)
    all_equal = len(set(data)) <= 1
    variance_is_zero = math.isclose(result, 0, abs_tol=1e-10)
    assert all_equal == variance_is_zero

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=50))
def test_stdev_equals_sqrt_of_variance_floats(data):
    """Test that stdev(data) == sqrt(variance(data)) for floating point data.
    
    This property tests the fundamental mathematical relationship between
    standard deviation and variance: stdev is the square root of variance.
    """
    import math
    
    stdev_result = stdev(data)
    variance_result = variance(data)
    sqrt_variance = math.sqrt(variance_result)
    
    assert math.isclose(stdev_result, sqrt_variance, rel_tol=1e-12)


@given(st.lists(st.integers(min_value=-1000, max_value=1000), min_size=2, max_size=50))
def test_stdev_equals_sqrt_of_variance_integers(data):
    """Test that stdev(data) == sqrt(variance(data)) for integer data.
    
    This property tests the fundamental mathematical relationship between
    standard deviation and variance with integer inputs.
    """
    import math
    
    stdev_result = stdev(data)
    variance_result = variance(data)
    sqrt_variance = math.sqrt(variance_result)
    
    assert math.isclose(stdev_result, sqrt_variance, rel_tol=1e-12)


@given(st.lists(st.decimals(min_value=-1000, max_value=1000, allow_nan=False, allow_infinity=False), min_size=2, max_size=20))
def test_stdev_equals_sqrt_of_variance_decimals(data):
    """Test that stdev(data) == sqrt(variance(data)) for Decimal data.
    
    This property tests the fundamental mathematical relationship between
    standard deviation and variance with Decimal inputs, which should
    maintain high precision.
    """
    from decimal import Decimal
    
    stdev_result = stdev(data)
    variance_result = variance(data)
    sqrt_variance = variance_result.sqrt()
    
    # For Decimals, we can compare directly since they maintain precision
    assert stdev_result == sqrt_variance


@given(
    st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=50),
    st.floats(allow_nan=False, allow_infinity=False)
)
def test_stdev_equals_sqrt_of_variance_with_xbar(data, xbar):
    """Test that stdev(data, xbar) == sqrt(variance(data, xbar)) when xbar is provided.
    
    This property tests the mathematical relationship holds even when
    an explicit mean (xbar) is provided to both functions.
    """
    import math
    
    stdev_result = stdev(data, xbar)
    variance_result = variance(data, xbar)
    sqrt_variance = math.sqrt(variance_result)
    
    assert math.isclose(stdev_result, sqrt_variance, rel_tol=1e-12)


@given(st.lists(st.fractions(min_value=-100, max_value=100), min_size=2, max_size=20))
def test_stdev_equals_sqrt_of_variance_fractions(data):
    """Test that stdev(data) == sqrt(variance(data)) for Fraction data.
    
    This property tests the fundamental mathematical relationship between
    standard deviation and variance with Fraction inputs.
    """
    import math
    
    stdev_result = stdev(data)
    variance_result = variance(data)
    sqrt_variance = math.sqrt(float(variance_result))
    
    assert math.isclose(float(stdev_result), sqrt_variance, rel_tol=1e-12)

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=100))
def test_variance_with_explicit_mean_equals_variance_with_none(data):
    """
    Test that variance(data, mean(data)) == variance(data, None).
    
    This property verifies that explicitly passing the mean as the xbar parameter
    produces identical results to letting variance calculate the mean internally.
    The variance function should behave identically whether the mean is provided
    or computed automatically.
    """
    import math
    
    # Calculate the mean of the data
    computed_mean = mean(data)
    
    # Get variance with explicit mean
    variance_with_mean = variance(data, computed_mean)
    
    # Get variance with None (auto-calculated mean)
    variance_with_none = variance(data, None)
    
    # They should be equal (using close comparison for floating point)
    assert math.isclose(variance_with_mean, variance_with_none, rel_tol=1e-15)


@given(st.lists(st.integers(min_value=-1000, max_value=1000), min_size=2, max_size=50))
def test_variance_with_explicit_mean_equals_variance_with_none_integers(data):
    """
    Test the same property with integer data to avoid floating point precision issues.
    
    With integer inputs, we can test for exact equality since there should be no
    floating point rounding errors when the same computations are performed.
    """
    # Calculate the mean of the data
    computed_mean = mean(data)
    
    # Get variance with explicit mean
    variance_with_mean = variance(data, computed_mean)
    
    # Get variance with None (auto-calculated mean)
    variance_with_none = variance(data, None)
    
    # They should be exactly equal for integer inputs
    assert variance_with_mean == variance_with_none


@given(st.lists(st.fractions(min_value=-100, max_value=100), min_size=2, max_size=20))
def test_variance_with_explicit_mean_equals_variance_with_none_fractions(data):
    """
    Test the same property with Fraction data for exact arithmetic.
    
    Using Fraction objects ensures exact arithmetic without floating point
    precision issues, allowing us to test for exact equality.
    """
    from fractions import Fraction
    
    # Calculate the mean of the data
    computed_mean = mean(data)
    
    # Get variance with explicit mean
    variance_with_mean = variance(data, computed_mean)
    
    # Get variance with None (auto-calculated mean)
    variance_with_none = variance(data, None)
    
    # They should be exactly equal for Fraction inputs
    assert variance_with_mean == variance_with_none

@given(st.lists(st.floats(allow_nan=False, allow_infinity=False), min_size=2, max_size=100))
def test_stdev_with_explicit_mean_equals_stdev_with_none(data):
    """
    Test that stdev(data, mean(data)) == stdev(data, None).
    
    This property tests that explicitly passing the mean as the xbar parameter
    produces the same result as letting stdev calculate it internally (None).
    """
    import math
    from statistics import stdev, mean
    
    # Calculate stdev with explicit mean
    data_mean = mean(data)
    stdev_with_mean = stdev(data, data_mean)
    
    # Calculate stdev with None (let it calculate mean internally)
    stdev_with_none = stdev(data, None)
    
    # Compare using math.isclose for floating point comparison
    assert math.isclose(stdev_with_mean, stdev_with_none, rel_tol=1e-15), \
        f"stdev with explicit mean {stdev_with_mean} != stdev with None {stdev_with_none}"


@given(st.lists(st.integers(-1000, 1000), min_size=2, max_size=50))
def test_stdev_with_explicit_mean_equals_stdev_with_none_integers(data):
    """
    Test that stdev(data, mean(data)) == stdev(data, None) for integer data.
    
    This tests the same property but with integer input data to ensure
    the equivalence holds across different numeric types.
    """
    from statistics import stdev, mean
    
    # Calculate stdev with explicit mean
    data_mean = mean(data)
    stdev_with_mean = stdev(data, data_mean)
    
    # Calculate stdev with None (let it calculate mean internally)
    stdev_with_none = stdev(data, None)
    
    # For integer data, the results should be exactly equal
    assert stdev_with_mean == stdev_with_none, \
        f"stdev with explicit mean {stdev_with_mean} != stdev with None {stdev_with_none}"


@given(st.lists(st.fractions(), min_size=2, max_size=20))
def test_stdev_with_explicit_mean_equals_stdev_with_none_fractions(data):
    """
    Test that stdev(data, mean(data)) == stdev(data, None) for Fraction data.
    
    This tests the same property but with Fraction input data to ensure
    the equivalence holds for exact rational arithmetic.
    """
    from statistics import stdev, mean
    
    # Calculate stdev with explicit mean
    data_mean = mean(data)
    stdev_with_mean = stdev(data, data_mean)
    
    # Calculate stdev with None (let it calculate mean internally)
    stdev_with_none = stdev(data, None)
    
    # For Fraction data, the results should be exactly equal
    assert stdev_with_mean == stdev_with_none, \
        f"stdev with explicit mean {stdev_with_mean} != stdev with None {stdev_with_none}"

@given(st.one_of(
    st.integers(),
    st.floats(allow_nan=False, allow_infinity=False),
    st.fractions(),
    st.decimals(allow_nan=False, allow_infinity=False),
    st.text(),
    st.booleans()
))
def test_single_element_central_tendency_equality(x):
    """
    Test that for single-element data [x], mean([x]) == median([x]) == mode([x]) == x.
    
    This property should hold for any single value regardless of type, as all three
    measures of central tendency collapse to the single value when there's only one
    data point.
    """
    from statistics import mean, median, mode
    import math
    from decimal import Decimal
    from fractions import Fraction
    
    single_element_data = [x]
    
    mean_result = mean(single_element_data)
    median_result = median(single_element_data)
    mode_result = mode(single_element_data)
    
    # For numeric types, we need to handle floating point comparison carefully
    if isinstance(x, float):
        # All results should be close to x and to each other
        assert math.isclose(mean_result, x, rel_tol=1e-15)
        assert math.isclose(median_result, x, rel_tol=1e-15)
        assert mode_result == x  # mode should return exact value
        assert math.isclose(mean_result, median_result, rel_tol=1e-15)
        assert math.isclose(mean_result, mode_result, rel_tol=1e-15)
    else:
        # For non-float types, exact equality should hold
        assert mean_result == x
        assert median_result == x
        assert mode_result == x
        assert mean_result == median_result == mode_result

@given(st.one_of(
    st.integers(),
    st.floats(allow_nan=False, allow_infinity=False),
    st.text(),
    st.booleans()
), st.integers(min_value=1, max_value=100))
def test_constant_data_central_tendency_equality(constant_value, list_length):
    """
    Test that for constant data [x, x, ..., x], all measures of central tendency
    (mean, median, mode) equal the constant value x.
    
    This property should hold for any constant value and any positive list length,
    across different data types including integers, floats, strings, and booleans.
    """
    from statistics import mean, median, mode
    import math
    
    # Create constant data list
    constant_data = [constant_value] * list_length
    
    # Calculate all measures of central tendency
    calculated_mean = mean(constant_data)
    calculated_median = median(constant_data)
    calculated_mode = mode(constant_data)
    
    # For floating point numbers, use approximate equality due to potential precision issues
    if isinstance(constant_value, float):
        assert math.isclose(calculated_mean, constant_value), f"Mean {calculated_mean} != {constant_value}"
        assert math.isclose(calculated_median, constant_value), f"Median {calculated_median} != {constant_value}"
        assert math.isclose(calculated_mode, constant_value), f"Mode {calculated_mode} != {constant_value}"
    else:
        # For exact types (int, str, bool), use exact equality
        assert calculated_mean == constant_value, f"Mean {calculated_mean} != {constant_value}"
        assert calculated_median == constant_value, f"Median {calculated_median} != {constant_value}"
        assert calculated_mode == constant_value, f"Mode {calculated_mode} != {constant_value}"
    
    # Additionally verify that all three measures are equal to each other
    if isinstance(constant_value, float):
        assert math.isclose(calculated_mean, calculated_median), f"Mean {calculated_mean} != Median {calculated_median}"
        assert math.isclose(calculated_median, calculated_mode), f"Median {calculated_median} != Mode {calculated_mode}"
        assert math.isclose(calculated_mean, calculated_mode), f"Mean {calculated_mean} != Mode {calculated_mode}"
    else:
        assert calculated_mean == calculated_median == calculated_mode, f"Not all equal: mean={calculated_mean}, median={calculated_median}, mode={calculated_mode}"

@given(st.floats(allow_nan=False, allow_infinity=False), 
       st.floats(allow_nan=False, allow_infinity=False))
def test_variance_equals_stdev_squared_for_two_elements(a, b):
    """
    Test that for two-element data [a, b]: variance([a, b]) == stdev([a, b])^2
    
    This verifies the fundamental relationship between variance and standard deviation
    (stdev = sqrt(variance)) for the minimal case where both functions are defined
    (requiring at least 2 data points).
    """
    import math
    from statistics import variance, stdev
    
    data = [a, b]
    
    # Calculate variance and standard deviation
    var_result = variance(data)
    stdev_result = stdev(data)
    
    # Test the fundamental relationship: variance = stdev^2
    stdev_squared = stdev_result ** 2
    
    # Use math.isclose for floating point comparison
    assert math.isclose(var_result, stdev_squared, rel_tol=1e-10), \
        f"variance([{a}, {b}]) = {var_result} != {stdev_squared} = stdev([{a}, {b}])^2"